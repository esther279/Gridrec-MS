/*  
   Compilation from Matlab:
   maybe a tiny bit faster code is generated by 
   mex -O COPTIMFLAGS='-O2' LDOPTIMFLAGS='-O2' set_projections_cpu_mex.c
 
   Usage from Matlab:
   set_projections_cpu_mex(probe,object,positions);
 
 This code in matlab:
 asize = size(probe);
 for i=1:Npos
    Indy = positions(i,1) + (1:asize(1));
    Indx = positions(i,2) + (1:asize(2));
    ob(Indy,Indx) = ob(Indy,Indx) + probe;
 end
 */

#include "mex.h"
#include <math.h> 
#include <stdio.h> 
#include <omp.h>


void mexFunction(int nlhs, mxArray *plhs[],
                 int nrhs, const mxArray *prhs[])
{
  int i;
    
    /* Check for proper number of arguments. */
  if (nrhs != 3) 
    mexErrMsgTxt("Three input arguments required: set_projections_cpu_mex(probe,object,positions,Npos)");
  else if (nlhs != 0) 
    mexErrMsgTxt("No output argument has to be specified.");
  
    /* Input must be of type single. */
  for (i=0; i < 2; i++) {
      if (mxIsSingle(prhs[i]) != 1){
          printf("Input %d is not single\n",i+1);
           mexErrMsgIdAndTxt("MexError:ptycho","Inputs must be of correct type.");
      }
  }
    /* Input must be of type int32. */
  for (i=2; i<nrhs; i++){
    if (mxIsInt32(prhs[i]) != 1){
          printf("Input %d is not integer\n",i+1);
          mexErrMsgIdAndTxt("MexError:ptycho","Inputs must be of correct type.");
    }
  }
 
    /* It cannot be one-dimensional */
  if(mxGetNumberOfDimensions(prhs[0]) < 2) {
    printf("The 1st input argument must have at least two dimensions.");
    mexErrMsgIdAndTxt("MexError:ptycho","wrong number of dimensions");
  }
    /* It cannot be more than 3-dimensional */
   if(mxGetNumberOfDimensions(prhs[0]) > 3) {
    printf("The 1st input argument must have at most three dimensions.");
    mexErrMsgIdAndTxt("MexError:ptycho","wrong number of dimensions");
  }
//   /* Check that arrays are complex */
//   if(mxIsComplex(prhs[0]) != 1) {
//       printf("object input argument must be complex-valued.");
//       mexErrMsgIdAndTxt("MexError:ptycho","Expected complex arrays");
//   }
//   if(mxIsComplex(prhs[1]) != 1) {
//       printf("probe input argument must be complex-valued.");
//       mexErrMsgIdAndTxt("MexError:ptycho","Expected complex arrays");
//   } 
  
  float *object_r, *object_i, *probe_r,*probe_i;
  int *positions;    
  bool cprobe, cobject;
          
  cobject =  mxIsComplex(prhs[0]);
  cprobe  =  mxIsComplex(prhs[1]);
  if( cobject != cobject) 
  {
          printf("probe/object input argument must be complex/real-valued.");
          mexErrMsgIdAndTxt("MexError:ptycho","Expected both complex / real arrays");
  }
 
    positions = (int*)mxGetData(prhs[2]);
    object_r = (float*)mxGetData(prhs[0]);
    probe_r = (float*)mxGetData(prhs[1]);
    if(cprobe)
    {
        /* get pointers to input data */
        object_i = (float*)mxGetImagData(prhs[0]);
        probe_i = (float*)mxGetImagData(prhs[1]);
    }

  
  /* Get dimension of probe and object */
  int Np_x, Np_y, No_x, No_y, Npos, Ndims;
  //int const * dims;
  const mwSize * dims;
  Ndims = mxGetNumberOfDimensions(prhs[1]);
  dims = mxGetDimensions(prhs[1]);
  No_y = mxGetM(prhs[0]);
  No_x = mxGetN(prhs[0]);
  Np_y = dims[0];
  Np_x = dims[1];
  Npos = mxGetM(prhs[2]);
  //printf("No_y =%i \n No_x = %i \n ", No_y, No_x);
  //printf("Np_y =%i \n Np_x = %i \n Npos = %i\n", Np_y, Np_x, Npos);

  if((Npos != dims[2]) && (Ndims == 3)) {
      printf("wrong size of update / positions  %i", Ndims);
      mexErrMsgIdAndTxt("MexError:ptycho","wrong size of update / positions");
  } 
  
  int id_small, id_large, pos, col, row; 
  bool flat_probe = Ndims == 2;

  #pragma omp parallel for private(pos) reduction(+:object_r,object_i)
  
  for (pos=0;pos<Npos;pos++){
      for (col=0;col<Np_x;col++) {
          for (row=0;row<Np_y;row++) {
              if(flat_probe)
                  id_small = row + col*Np_y;
              else
                  id_small = row + col*Np_y + Np_y*Np_x*pos;

              id_large = row + positions[pos] + (col+positions[pos+Npos])*No_y;
              object_r[id_large] +=  probe_r[id_small];
	      
	      //printf("pos[%i],(%i,%i) id_large = %i, id_small = %i; cprobe %i\n", pos, col, row, id_large, id_small, cprobe);
	      
              if(cprobe)	      
                object_i[id_large] +=  probe_i[id_small];
		}
      }
      }
  //}
  


  
  return;
  
}

